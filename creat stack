#include <stdio.h>
#include <stdlib.h>
#define max 20
//typedef struct SNode *stack;
typedef char element;
typedef int position;
struct SNode
{
    element *data;//操作的元素
    position top;//栈顶位置的数组下标
    int value[max];
    int maxsize;
    //链表表示的堆栈
    //element data;
    //struct snode *link;//SNode类型的指针

};
typedef struct SNode *stack;
void redfromfile(char *str);//从txt中读出来,读进一个数组里
void printfSN(char *str);//把中缀表达式读出来
stack creatstack(int maxsize);
void push(stack ptrs,element x);//
char pop(stack ptrs);//
int labvalue(char x);//
void possorting(char *str,stack ptrs);
void ptintf(stack s);
int main()
{
    stack s;
    char str[max];
    int maxsize=10;
    redfromfile(str);//从txt中读出来,读进一个数组里
    printfSN(str);
    s=creatstack(maxsize);//创立堆栈
    possorting(str,s);
    return 0;
}

//从文件中读取字符串
void redfromfile(char *str)
{
    FILE*fp;
    int i=0;
     if((fp=fopen("E://poly.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    fscanf(fp,"%c",&str[0]);
    //满足条件才能开始
    if(str[0]=='#'){
        do{
        i++;
        fscanf(fp,"%c",&str[i]);
        }while(str[i]!='#');
        str[i]='\0';
    }
}

void printfSN(char *str)
{
    int i;
    for(i=1;str[i]!='\0';i++){
        printf("%c",str[i]);
    }
    printf("\n");
}

//建立一个堆栈,大小为max
stack creatstack(int maxsize)
{
    stack ptrs=(stack)malloc(sizeof(struct SNode));
    ptrs->data=(element *)malloc(maxsize *sizeof(element));
    ptrs->top=-1;
    ptrs->maxsize=maxsize;
    return ptrs;
    //ptrs->top[max]=-1;
    //return ptrs;
    //ptrs->top=-1;
    //ptrs->value[max]=-1;
}

//压入堆栈
void push(stack s,char x)
{
    if(s->top==max-1){
        printf("full");
    }else{
        s->data[++(s->top)]=x;
        //printf("%c",x);
        //printf("%c\n",s->data[(s->top)]);
        int  m=labvalue(x);
        s->value[(s->top)]=m;
        //printf("%d\n",s->value[(s->top)]);
        //return ptrs;
    }
}

//弹出栈
char pop(stack s)
{
    char x;
    if(s->top==-1){
        printf("www没有元素");
        return 0;
    }else{
        x=s->data[(s->top)--];
    }
    return x;
}

//对运算级别进行赋值
int labvalue(char x)
{
    int value;
    switch(x){
        case '+':
        case '-':
            value=0;
            break;
        case'/':
        case'*':
            value=1;
        default:
            value=-1;
            break;
    }
    return value;
}

//打印栈的情况
void ptintf(stack s){
    int i;
    if(s->top>=0){
        for(i=0;i<=s->top;i++){
        printf("堆栈元素%c",s->data[i]);
        }
        printf("\n");
    }else{
    printf("堆栈无元素\n");
    }
}
//进行后缀排序
void possorting(char *str,stack s)
{
    int i;int value;
    char m,x;
    //没有读取完，依次进行操作
    printf("输出字符\t");
    //printf("\t\t");
    printf("堆栈情况\n");
    for(i=1;str[i]!='\0';i++){
        if(str[i]=='+' || str[i]=='-' || str[i]=='/' ||str[i]=='*' ){
        //遇到运算符的情况
            value=labvalue(str[i]);
            if(s->top==-1)
            {
                push(s,str[i]);
                //exit(0);
            }else{
                while(value <= s->value[s->top]){
                    x=pop(s);
                    printf("%c",x);
                    //不能一直比较啊，必须判断栈空不空！！！，如果栈空value[-1]没有意义，并没有给没有元素时，value定义
                    if(s->top==-1)
                    break;
                }
                push(s,str[i]);
            }
        }else if(str[i]=='('){
            //遇到左括号的情况,压入堆栈
            push(s,str[i]);
        }else if(str[i]==')'){
        /*遇到右括号的情况,栈顶的运算符弹出，直到遇到左括号
        但是，左括号不输出*/
            while(s->data[s->top]!='('){
                m =pop(s);
                printf("%c",m);
            }
            m=pop(s);//输出左括号
            /*m =pop(s);
            do{
            printf("%c",m);
            m =pop(s);
            }while(m!='(');*/
        }else{
        //遇到数字
        //ptintf(s);
        printf("%c",str[i]);
        }
    //printf("\t\t");
    //ptintf(s);
    }
    while(s->top!=-1){
        x=pop(s);
        printf("%c",x);
    }
}





/*

//读取信息
void redfromfile(polypointer a,int *m)
{
    FILE*fp;
    int i;
    polypointer pre,prt,t;
     if((fp=fopen("E://experiement.txt","r"))==NULL)
    {
        printf("fail to open!");
        exit(0);
    }
    fscanf(fp,"%d\n",m);//A式子的项数
    pre=a;
    for(i=1;i<=*m;i++)
    {
        t=(polypointer)malloc(sizeof(struct polynode));
        fscanf(fp,"%f %f\n",&(t->exp));ASER
        pre->link=t;
        pre=t;
    }
    pre->link=NULL;
}

//生成空堆栈
stack createstack(int maxsize)
{
    //??
    stack s;
    s=(stack)malloc(sizeof(struct SNode));//创建SN类型的结点
    s->link=NULL;
    return s;
}

//判断堆栈是否满
int isempty(stack s)
{
    return (s->link==NULL);
}

//压栈push(stack类型的指针)
void push(stack s,element x)
{
    stack p;
    p=(stack)malloc(sizeof(struct SNode));
    p->data=x;
    p->link=s->link;
    s->link=p;
}

//弹出pop，返回栈顶元素
element pop(stack s)
{
    stack firstcell;
    float topelem;
    if(isempty(s)){
        printf("空");
        return -1;
    }else{
       firstcell=s->link;
       s->link=firstcell->link;
       topelem=firstcell->data;
       free(firstcell);
       return topelem;
    }
}
